%% Author; Muhammed Shifas PV, shifaspv@csd.uoc.gr
% This is a Matlab implimentation of our paper "Muhammed Shifas P.V., Jayakumar E.P., Sathidevi P.S. (2018) Robust Acoustic Echo Suppression in Modulation Domain.
% ,Progress in Intelligent Computing Techniques: Theory, Practice, and Applications. Advances in Intelligent Systems and Computing, vol 719. Springer, Singapore"

%%
close all;
clear all;
clc;
delete('clean.wav','enhanced.wav')% clearing the samples generated by last run
% Online impuls response generator
fs=8000;
mic=[2 1.5 .5];
n=8;
r1=0.6;
rm=[5 4 3];
src=[5 2 1];
h=rir(fs, mic, n, r1, rm, src);% details can be found in the corresponding function
L=length(h)

%input signal on which experiments run
[x, Fs] = audioread('S_01_01.wav'); %Far-end signal
[v, Fs] = audioread('S_01_02.wav'); %Near-end signal
v=[zeros(8000,1);v(8000:end)]; % putting silence at t%he ends

% Echo signal corresponds to the specified room response
EchoSignal=filter(h,1,x); 
P_near=bandpower(v);
P_echo=bandpower(EchoSignal);
while (P_echo>=0.448*P_near) % keeping the echo power below a threshold of near-end speech
    x=0.99*x;
    EchoSignal=filter(h,1,x);
    P_echo=bandpower(EchoSignal);
end
% Listen the sound files generated abovesubplot(212)



M=length(v);
N=length(EchoSignal);%
v=[zeros(N-M,1);v];
disp('echo in the microphone')
sound(EchoSignal)
pause(2)
disp('near-end speeech')
sound(v)
pause(2)
disp('combined microphone input (echo + near-end)')
y=EchoSignal+v; %(Microphone Signal)
sound(y)
%% Main Function
% DELAY ESTIMATION
delay=finddelay(x,y);
x1=[zeros(ceil(delay),1);x];
DTbegin=1;

%initializing statistical variables
alpha=0.1;
T1=0.8;  % for Double Talk Detector (DTD)subplot(212)
T2=0.3;
t=10e-3;       %frame length in ms
ni=floor(Fs*t);
% nf=floor(length(y)/ns);
ov=2;
nf=ov*ni;
c1=0.998;
r1=0.998;
eta=0.92;
flag=0;
beta=3;
alf=0.8;
G=1;

%STFT calculation
w=sqrt(hamming(nf+1))'; w(end)=[];  % for now always use sqrt hamming window
w=w/sqrt(sum(w(1:ni:nf).^2));       % normalize to give overall gain of 1
X1=fft(enframe(x1,w,ni),nf,2);
Y1=fft(enframe(y,w,ni),nf,2);
V1=fft(enframe(v,w,ni),nf,2);
[a,b]=size(Y1);
% selecting phase and magnitude
xphase=angle(X1);
xspec=abs(X1);
yphase=angle(Y1);
yspec=abs(Y1);
xspec1=xspec';
yspec1=yspec';
vphase=angle(V1);
vspec=abs(V1);
vspec1=vspec';

% now onwards the FFT transformation are into modulation domain
[u,r]=size(xspec1);
nf1=5;% frame size in samples of modulation spectra (can be changed)
ni2=2; % frame increment in samples of modulation spectra (can be changed)
w1=sqrt(hamming(nf1+1))'; w1(end)=[];  % for now always use sqrt hamming window
w1=w1/sqrt(sum(w1(1:ni:nf1).^2));       % normalize to give overall gain of 1
nf2=nf;
for k=1:nf
    % going to modulation spectra
    xms=enframe(xspec1(k,:),w1,ni2);
    xmsf=(fft(xms,nf2,2));
    yms=enframe(yspec1(k,:),w1,ni2);
    ymsf=(fft(yms,nf2,2));
    xyp=xmsf.*conj(xmsf);
    yyp=ymsf.*conj(ymsf);
    vms=enframe(vspec1(k,:),w1,ni2);
    vmsf=(fft(vms,nf2,2));
    
    
    [c,d]=size(yyp);    
    clear C;clear R; clear f1
    flag=0;
    px=10^-30;
    pzd=10^-30;
    pd=10^-30;
    pz=10^-30;
    pze=10^-30;
    pe=10^-30;
    ps=10^-30;
    % Modulation domain Gain estimation for echo suppression
    for z=1:c     
        if flag==0
            if z==1
                C=(1-c1)*abs(ymsf(z,:).*conj(xmsf(z,:)))+1e-10;
                R=(1-r1)*abs(xmsf(z,:).*conj(xmsf(z,:)))+1e-10;
            else
                
                C=c1*C+(1-c1)*abs(ymsf(z,:).*conj(xmsf(z,:)));
                R=r1*R+(1-r1)*abs(xmsf(z,:).*conj(xmsf(z,:)));
                
            end
            H1=C./R;
        end
        Y_hat=(H1).*abs(xmsf(z,:));
        Y_hat=beta*Y_hat;
        abs_Y_hat(z,:)=Y_hat;
        gi=((max((abs(ymsf(z,:)).^2-Y_hat.^2),0)./(abs(ymsf(z,:)).^2)).^0.5);
        S=ymsf(z,:).*gi;
        
        %%  Modulation domain DTD
        pzd=(1-alpha)*pzd+alpha*abs(ymsf(z,:)*(Y_hat'));
        pd=(1-alpha)*pd+alpha*(abs(Y_hat*Y_hat'));
        pz=(1-alpha)*pz+alpha*(abs(ymsf(z,:)*ymsf(z,:)'));
        pze=(1-alpha)*pze+alpha*abs(ymsf(z,:)*(S)');
        pe=(1-alpha)*pe+alpha*(abs(S*S'));
        l=z;
        rzd=pzd/(sqrt(pz*pd));
        rze=pze/(sqrt(pz*pe));
        m1(l)=(rzd);
        m2(l)=(rze);
        
        if (l>DTbegin)
            if abs(m1(l))<T1
                if abs(m2(l))>T2
                    
                    flag=1;
                    f1(l)=1;
                    
                else
                    
                    flag=0;
                    f1(l)=0;
                end
            else
                flag=0;
                f1(l)=0;
            end
        end
        g(z,:)=gi;              % save gain for later
        %                 x(z,:)=xi;              % save prior SNR
        %                 xu=gami.*gi.^2;         % unsmoothed prior SNR
        
    end
    se=(ifft((ymsf.*g),nf2,2));     % inverse dft and apply output window; back to frequency domain
    [y1,p]=overlapadd(se,ni2);
    ss(k,:)=y1;
    se1=(ifft(vmsf.*g,nf2,2));     % inverse dft and apply output window; back to frequency domain
    [y11,p]=overlapadd(se1,ni2);
    sv(k,:)=y11;
end
p_rec=ss.';
[n,m]=size(p_rec);
se2=(ifft(p_rec.*exp(i*yphase(1:n,:)),nf,2));     % inverse dft and apply output window; back to time domain
[y2,p]=overlapadd(se2,w,ni) % overlap add
ss1=0.26*y2; % regining to be bounded

%%Plots of different signals and ERLE
 disp('echo cancelled signal')
sound(real(ss1))
subplot(211)
spectrogram(y,hamming(nf),ni,nf,fs,'yaxis')
title ('microphone input (echo+near end speech) ')
subplot(212)
spectrogram(v,hamming(nf),ni,nf,fs,'yaxis')
title('clean near end speech')
% % ERLE and plots
%m=length(y3);
m=length(ss1);
n=length(y);
ul=min(m,n);
for i=1:ul
powerY(i) = abs(y(i))^2; %Power of Microphone 
powerE(i)=abs(ss1(i))^2; %power of Error 
end
L=2000;
for i=5:N-2*L   
%Echo Return Loss Enhancement
ERLE(i)=10*log10(mean(powerY(i:i+L))/mean(powerE(i:i+L)));
end
load feller
figure
subplot(211)
spectrogram(real(y3),hamming(nf),ni,nf,fs,'yaxis')
title('echo cancelled (Frequency domain:Feller et.al)')
 load feller.mat
subplot(212)
 spectrogram(real(ss1),hamming(nf),ni,nf,fs,'yaxis')
title('echo cancelled (proposed MDAES method)')
figure
plot(ERLE1)
hold on
 plot(ERLE,'g')
title ('Echo Return Loss Enhancement (ERLE) plot')
xlabel('samples')
ylabel('ERLE in dB')
legend('Feller and Tournery','Proposed')